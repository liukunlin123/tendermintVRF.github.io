#### Forward Secure Signatures and FKES
在常规的数字签名方案中，破坏用户签名密钥的对手可以为其希望的任何消息（包括过去（或应该已经）生成的消息）生成签名。前向安全签名方案[BM99]可防止此类攻击者为过去发出的消息生成签名，或者允许诚实用户验证在特定时间点生成了给定签名。基本上，这样的安全保证是通过在生成每个签名后“演变”签名密钥并擦除以前的密钥的方式来实现的，这种方式使得过去用于签名消息的实际签名密钥无法恢复，但是可以使用新的签名密钥仍然链接到上一个。此概念通过密钥演变签名方案来正式化，该方案允许在多个时间段内将签名密钥演化为新密钥。我们指出，存在具有前向安全性的密钥演进签名方案的有效构造[IR01]，但以前的工作尚未在UC设​​置中完全指定它们。先前（基于游戏的）定义在附录A.3中给出。

我们为密钥演化签名的类型提供了一个UC定义，我们将在我们的构造中加以利用。 FKES允许我们通过擦除来实现前向安全性（即假设当协议进行时各方安全地删除了旧的签名密钥）。此功能体现了理想的密钥演变签名方案，允许破坏签名者的对手只能在当前和将来的签名密钥下伪造签名，而不能在已更新的先前签名密钥下伪造签名。 FKES的起点是[Can04]中定义的标准数字签名功能，其区别在于将签名操作与密钥演变操作打包在一起。在验证过程中，FKES允许对手设置对验证查询的响应（以输入给定时间段），前提是自该时间段以来未执行任何密钥更新，并且其内部表中没有针对查询中指定的特定消息，签名和时间段的条目。我们在图1中给出FKES。在附录B中，我们将显示可以通过基于附录A.3中定义的密钥演进签名方案的构造来实现FKES。


#### UC-VRFs with Unpredictability Under Malicious Key Generation
The genesis block $B_0$ contains the list of stakeholders identified by a label $U_i$, their respective public keys and respective stakes
$S_0 = ((U_1, v_1^{vrf}, v_1^{kes}, v_1^{dsig}, s_1), \dots, (U_n, v_n^{vrf}, v_n^{kes}, v_n^{dsig}, s_n))$
and a nonce $\rho$.
VRF的通常伪随机定义（如附录A.1中的定义14所述）反映了以下事实：攻击者看到了许多VRF输出以及在挑战者正确生成的密钥对下针对对手选择的输入的证明，而无法从真正的随机字符串中区分出新输入（也经过对抗选择）上的VRF输出。对于我们的目的，此定义太弱了，原因有二：首先，我们需要基于仿真的定义，以便可以在协议中直接组成VRF。其次，即使在恶意密钥生成的情况下，即针对允许生成秘密和公开密钥对的对手，我们也需要原语提供某种程度的不可预测性。标准VRF安全定义甚至[CL07]的可模拟VRF概念都不能隐含我们对VRF的UC表示。例如，我们设置的VRF证明必须在不了解VRF输出的情况下是可模拟的（这很关键，因为我们希望确保VRF输出不会过早泄露给对手）；构建标准定义中安全的VRF很容易，但是如果不了解VRF输出，就不可能模拟其证明。此外，如果允许对手生成自己的密钥对，则很容易看出，不能保证VRF输出的分布。实际上，即使对于已知的结构（例如[DY05]），恶意生成密钥的对手也可能轻易且显着地歪曲输出分布。
![Alt text](Praos中的VRF.png)


