### VRF原理简介
![Alt text](微信图片_20200809194751.png)
![Alt text](微信图片_20200809194805.png)
![Alt text](微信图片_20200809194809.png)

### VRF的优点
1.首先它的抽签过程不需要与其他通信，直接在本机就能够的到这个抽签结果，而且这个x输入是大家公认的，针对同一个x的输出value是固定的，因此无法通过多次尝试来改变抽签结果。
2.某个节点收到其他节点的抽签信息之后，可以用附带的证明，来证明这个随机数的正确性，保证它的确是由私钥的拥有者计算出来的。因此这个抽签结果是无法被伪造的。
3.VRF主要用来的得出一个伪随机数，抽签的部分主要是由一个二项分布函数负责，而通过构建二项分布的参数，我们可以很方便的控制需要被得出的中签权益的个数，适配不同的需要抽签的场景。

### VRF的应用
#### Ouroboros
**1.对术语的介绍和解释**
**slot**：在Cardano的运行中，时间被分为 slot。每个slot只能产生一个块，若这个块有问题，或者应该产出这个块的“矿工”(也就是stakeholder的候选人)不在线，或者产出的块没有广播给大多数人，那么这个slot是当作废弃的，也就是会跳过这个slot的块。、
**epoch**：多个slot为一个 epoch，权益的计算是以每个epoch开始前的历史来计算，也就是说在这个epoch中所产生的权益变化不影响当前的这个epoch中的slot的出块者的选择和其他和历史相关的东西。当前epoch中所产生的这些历史只能在以后的epoch中生效。
**genesis block**：每个epoch的开头有个 genesis block(注意是每一个epoch，不是整个链)，这个genesis block 不会上链(整个链初始的那个genesis会，当然这一点可以根据实现自己决定)，而是当前这个节点(矿工)自己在内存中生成，这个genesis block会记录好当前这个epoch中的可能参与出块的 stakeholder的候选人，及一个随机种子ρ。
**stackholder**:stakeholder是权益持有者，也就是潜在矿工，在Cardano的实现中权益stake并不是直接指代有多少Ada，而是和有多少Ada相关联(更详细的我不是很清楚)，同时要成为一个stakeholder需要有2%的Ada才行。当然论文中不关注这些，直接定义了stakeholder。而stakeholder并不一定要参与出块，只有记录在每个epoch的genesis block中的stakeholder才能参与当前epoch中slot的出块，所以记录在每个epoch中的genesis block中的stakeholder叫做 “stakeholder候选人”。
**slot leader**：Slot Leader是指根据权益占比选择按概率选择出的当前slot的出块者。

**2.Ouroboros总体运行流程**
1).从链的真正创世块开始，硬编码进入了一些公钥和这些公钥vk对应的权益s及初始的种子ρ，之后，这个epoch会采用这些基础信息继续运行。
2).每个节点自己独立运行代码，根据当前epoch的种子ρ，执行F(比如 follow-the-satoshi)，把genesis block中的权益，ρ和slot的index作为输入，根据概率获得当前这个slot应该由谁出块。
i).若发现是自己出块，则执行打包交易等等操作，和bitcoin没有太大区别，但是除了基础工作之外，还会生成一个随机数，但是这个随机数不放到链(块)中，而是放一个承诺(后文解释)。
ii).若不是自己出块，则等待出块者出块并广播。收到这个块的时候就进行和bitcoin类似的检查，要是长时间未收到(超出这个slot的时间)则会认为这个slot的块废弃。
3).在当前epoch中不断重复2的流程直到这个epoch中的所有slot结束。
4).在整个epoch的过程中会产出一个在这个epoch参与出块者们(slot leaders)都共同认同的随机种子ρ。
5).在自己的内存里记录好这个ρ及下一个epoch参与的stakeholders，开启下一个epoch周期，进入2的流程。

**3.存在的安全问题**
在每个epoch开始之前，上一轮epoch中，会确定一个random seed，以及若干Stake Holders。产生了这个Random Seed之后，然后用Follow the Satoshi算法，得到每个slot的slot leader，可以将Follow the Satoshi看作是一个随机预言机，可以利用Random Seed以及每个Stake Holder的权益值，给每个slot随机分配一个stake holder作为slot leader，而这个结果是在这一次 epoch 开始之前，每个节点都知道的，它们可以自己算出来。
这样就会有一个问题：我可以提前知道某个区块的打包节点，那么攻击者就可以提前攻击这个打包节点，来达到它攻击的目的。

**4.引入VRF**
引入了VRF之后，每一轮的slot的slot leader只有这个节点自己知道，他发布之后，其他节点可以验证他是不是真有这个角色，这样就可以避免上面所说的攻击。
但是，可能出现某一轮slot没有抽出slot leader或者抽出了多个slot leader的情况。
实际上，这个问题不论是Follow the Satoshi还是VRF的方案，都必须去解决，因为就算我能保证每个slot都有slot leader，我也没办法保证slot leader是否能在这个slot里打出包来。而验证分叉的方案，又是只要是链就一定会考虑的问题，假设某个slot leader被攻击，而在自己的slot里大量重复打包，也会造成分叉问题。
所以在没有新问题引人的情况下，增加了打包节点的匿名性，实际上是对系统有了一个安全性上的升级。

#### Algorand
选取共识委员会成员
![Alt text](微信图片_20200809211324.png)
![Alt text](微信图片_20200809211508.png)
![Alt text](微信图片_20200809211328.png)

#### Dfinity
“阈值签名接力”

#### VBFT
1.根据 VRF 从共识网络中选择备选提案节点，各个备选节点将独立提出备选区块；
2.根据 VRF 从共识网络中选择多个验证节点，每个验证节点将从网络中收集备选的区块，进行验证，然后对最高优先级的备选区块进行投票；
3.根据 VRF 从共识网络中选择多个确认节点，对上述验证节点的投票结果进行统计验证，并确定出最终的共识结果。
4.所有节点都将接收确认节点的共识结果，并在一轮共识确认后开启新的共识。

VBFT算法可以其实本质上还是一种BFT算法，但是它在传统的算法基础上，引入了"可验证随机函数"，也就是说在VBFT算法中，首先基通过VRF进行计算，并且随机筛选出区块验证节点集和区块确认节点集，然后由选出的节点集通过BFT算法来完成共识。由于VRF引入的随机性，每轮区块的备选提案节点／验证节点／确认节点都不相同，难以事先预测，从而极大的提高了共识算法的抗攻击能力，这是一个巨大的优点。



1.弱中心？

2.打包者的数量？

3.阶段的数量？

