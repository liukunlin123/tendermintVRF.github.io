#### Praos
***为每个slot选取slot leader时用到了VRF。***
对VRF进行了一些改进，实现了一个叫UC-VRF的函数，该函数可以抵挡某些恶意攻击，如malicious key generation，malicious VRF evaluation等。

#### Algorand
***VRF结合POS，选取参与BA^*^共识的共识委员会成员。***
![Alt text](Algorand中的VRF.png)
![Alt text](Algorand中的VRF1.png)
![Alt text](Algorand中的VRF2.png)
##### BA^*^算法
![Alt text](Algorand中的BA星算法.png)

**1.Reduction**: 全网将对所有共识成员观察到的区块进行共识的问题转换成对某个区块或者空块进行共识问题, 这里分为两个步骤（如Algorithm 7）：

**1.1** CommiteeVote 该算法授权检查自己是否为共识成员，如果是则将自己观察到的区块hash广播到网络中去
**1.2** 等待的时间，收集大部分用户投票的区块
**1.3** 如果步骤1.2超时则提议投票给空块，否则将1.2中获得的区块提交出去 （为啥还需要后续过程，因为本过程只能够保证当前节点已经知晓网络中大多数同意的区块，类似PBFT算法中的Prepare阶段之后还需Commit）

**2.BinaryBA***
BinaryBA* 算法将会在一个最大步数限制的情况下进行多次投票，在网络状况良好的情况下函数会在step=1的时候停止。

**2.1** step = 1 时，用户判断自己是否投票委员会成员，如果是则将Reduction中得到的区块hash进行投票，并收集结果，如果此时已经达到共识，另外发送三次投票（为了其他用户共识时能够收集到足够数量的投票）并尝试将该区块状态标记为final；
**2.2** 当2.1 返回为空或者超时的情况下将再次发起投票，并收集结果。如果确实为空则证明本轮共识为空块，此时将发起三次投票（同上）；如果是超时说明2.1中的失败并非为空而是收集投票未到达规定阈值，继续进行投票；
**2.3** 本次如果超时，那么会运行CommonCoin函数，该函数将给足网络时间去同步投票信息。同时该函数会随机让系统用户选择下一轮投空还是投blockhash，从而让攻击者只有1/2的命中率。

**3.CountVotes**: 对标记为FINAL的区块进行计数，取得足够数量的FINAL标记将被持久化到区块链中。

#### Dfinity
***VRF为更高层提供随机源。***
![Alt text](Dfinity.png)
**Dfinity的共识机制层**
1.身份层：提供所有客户端的注册表。
2.随机信标层：为包括应用程序（智能合约）在内的所有更高层提供随机源（VRF）。
3.区块链层：通过随机信标驱动的协议，从已验证的交易中构建区块链。
4.公证层：为客户和外部观察者提供快速的确定性保证。

第二层中的随机信标是由注册客户共同生成的无偏，可验证的随机函数（VRF），任何人都无法预测VRF的输出，直到它对所有人都可用为止。

#### VBFT
***用VRF选取备选提案节点，验证节点以及确认节点。***
VBFT的每轮共识中，
1.根据VRF从共识网络中选择备选提案节点，各个备选节点将独立提出备选区块；
2.根据VRF从共识网络中选择多个验证节点，每个验证节点将从网络中收集备选的区块，进行验证，然后对最高优先级的备选区块进行投票；
3.根据VRF从共识网络中选择多个确认节点，对上述验证节点的投票结果进行统计验证，并确定出最终的共识结果。
4.所有节点都将接收确认节点的共识结果，并在一轮共识确认后开启新的共识。

当前VBFT算法中的每一轮区块的VRF值都是由前一轮共识区块所确定的。具体算法是从上一个区块中提取易变信息，然后计算哈希，生成的1024位的哈希值，将此哈希值作为下一个区块的VRF值。

#### 专利
***用VRF选举提案节点以及确认节点。***

下面是选取的具体步骤
##### 选民向弱中心发送消息

选民用VRF函数生成哈希hash和证明π并进一步生成包含身份及选举轮次信息的字符串X，选民用弱中心公钥加密字符串X得到PK~中心~(X)并发送给弱中心

(PK~选民半密钥~+hash+π+seed +r)Pk~中心~

选民发给弱中心的密钥为其公钥PK~选民~的半密钥PK~选民半密钥~，这是为了确保选民被弱中心选中后，弱中心及接收到广播消息的其他选民都无法在当前阶段就知晓谁被选举为委员。弱中心此时也不知道谁是主官、谁是副官，主官和副官相互之间也不明身份。但弱中心掌握了所有委员会委员当前轮次的半密钥PK~选民半密钥~、hash和π值。在投票时，被选中的委员才会带上另一半密钥，这样才能让其他节点（主要是弱中心）验证某一票是否来自于合法的被选举出的委员

##### 弱中心盲选委员
1.弱中心等待指定的时间t后，将收到的PK~中心~(X)用私钥SK~中心~解密得到每一个选民的哈希hash和选民用VRF函数生成的证明π，计算收到哈希hash和选民用VRF函数生成的证明π的结果数量N~hash+π~，如果结果数量N~hash+π~大于指定的数量N成立，则跳转执行步骤2；否则，跳转执行步骤1

2.弱中心随机生成一个长度为N~hash+π~的位串，且N个位为1，N~hash+π~-N位为零，其中N的值为3f+1，f为拜占庭容错的最大值

3.弱中心逐个计算长度为N~hash+π~的位串和~Nhash+π~个选民的哈希hash以及选民用VRF函数生成的证明π三者的散列哈希值，并将得到N~hash+π~个散列哈希值按照大小依次排序

4.根据长度为N~hash+π~的位串信息，按照从低位到高位的顺序，递增排列所有选民的散列哈希值，对应位为1的选民被选中为委员，确定被选中的N个委员，且被选中的N个委员中哈希值最小的委员指定为主官、其余N-1个选民为副官

5.弱中心将N个被选中委员列表信息分别生成校验值以及用私钥SK~中心~加密，N个被选中委员列表信息包括N个委员的哈希hash、选民用VRF函数生成的证明π、VRF函数种子seed以及选举轮次r，然后将加密结果以及校验值分别发送给所有选民

6.选民在收到被选中委员列表信息后，首先用弱中心的公钥PK~中心~解密字符串，然后用指定的校验算法对字符串中相同内容重生成校验值，如果两者校验值相同，则表示收到的信息未被篡改过，跳转执行步骤7；如果不同，则直接丢弃，跳转执行步骤1

7.选民将自身包含的哈希hash遍历查询N个被选中委员列表信息包括的N个委员的哈希hash，如果找到匹配的结果则判定自身被选中为委员，否则判定自身未被选中为委员

8.N个被选中委员列表信息复原长度为N~hash+π~的位串，并逐个计算复原长度为N~hash+π~的位串和各个委员的哈希hash以及选民用VRF函数生成的证明π三者的散列哈希值，并将得到N~hash+π~个散列哈希值，按照大小依次排序，从而确定自身是否为主官

