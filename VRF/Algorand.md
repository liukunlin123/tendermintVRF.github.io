![Alt text](Algorand中的VRF.png)
![Alt text](Algorand中的VRF1.png)
![Alt text](Algorand中的VRF2.png)

#### BA*算法
![Alt text](Algorand中的BA星算法.png)

**1.Reduction**: 全网将对所有共识成员观察到的区块进行共识的问题转换成对某个区块或者空块进行共识问题, 这里分为两个步骤（如Algorithm 7）：

**1.1** CommiteeVote 如算法4描述该算法授权检查自己是否为共识成员，如果是则将自己观察到的区块hash广播到网络中去
**1.2** 等待的时间，收集大部分用户投票的区块 T*t
**1.3** 如果步骤1.2超时则提议投票给空块，否则将1.2中获得的区块提交出去 （为啥还需要后续过程，因为本过程只能够保证当前节点已经知晓网络中大多数同意的区块，类似PBFT算法中的Prepare阶段之后还需Commit）

**2.BinaryBA***
BinaryBA* 算法将会在一个最大步数限制的情况下进行多次投票，在网络状况良好的情况下函数会在step=1的时候停止。

**2.1** step = 1 时，用户判断自己是否投票委员会成员，如果是则将Reduction中得到的区块hash进行投票，并收集结果，如果此时已经达到共识，另外发送三次投票（为了其他用户共识时能够收集到足够数量的投票）并尝试将该区块状态标记为final；
**2.2** 当2.1 返回为空或者超时的情况下将再次发起投票，并收集结果。如果确实为空则证明本轮共识为空块，此时将发起三次投票（同上）；如果是超时说明2.1中的失败并非为空而是收集投票未到达规定阈值，继续进行投票；
**2.3** 本次如果超时，那么会运行CommonCoin函数，该函数将给足网络时间去同步投票信息。同时该函数会随机让系统用户选择下一轮投空还是投blockhash，从而让攻击者只有1/2的命中率。

**3.CountVotes**: 对标记为FINAL的区块进行计数，取得足够数量的FINAL标记将被持久化到区块链中。



